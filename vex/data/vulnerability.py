# This implementation contains code from Anthony Harrison, licensed by Apache-2.0
# Remediation management have been updated
import logging

class Vulnerability:
    def __init__(self, validation=None):
        self.vulnerability = {}
        if validation is not None and validation in [
            "openvex",
            "csaf",
            "cyclonedx",
            "spdx",
        ]:
            self.validation = validation
        else:
            self.validation = None

    def initialise(self):
        self.vulnerability = {}
        self.vulnerability["remediations"] = []
        self.vulnerability["justifications"] = []

    def set_name(self, name):
        self.vulnerability["product"] = name

    def set_release(self, release):
        self.vulnerability["release"] = release

    def set_id(self, id):
        self.vulnerability["id"] = id

    def set_description(self, description):
        self.vulnerability["description"] = description

    def set_comment(self, comment):
        self.vulnerability["comment"] = comment

    def validate_status(self, status):
        if self.validation in ["openvex", "spdx"] and status in [
            "not_affected",
            "affected",
            "fixed",
            "under_investigation",
        ]:
            return True
        elif self.validation == "cyclonedx" and status in [
            "resolved",
            "resolved_with_pedigree",
            "exploitable",
            "in_triage",
            "false_positive",
            "not_affected",
        ]:
            return True
        elif self.validation == "csaf" and status in [
            "first_affected",
            "first_fixed",
            "fixed",
            "known_affected",
            "known_not_affected",
            "last_affected",
            "recommended",
            "under_investigation",
        ]:
            return True
        return False

    def set_status(self, status):
        if self.validation is None:
            # No validation performed
            self.vulnerability["status"] = status.lower()
        elif self.validate_status(status.lower()):
            # Valid field according to specification
            self.vulnerability["status"] = status.lower()
        else:
            # Invalid field detected
            # Set to default state
            if self.validation == "cyclonedx":
                self.vulnerability["status"] = "in_triage"
            else:
                self.vulnerability["status"] = "under_investigation"

    def validate_justification(self, justification):
        if self.validation == "openvex" and justification._get_type() in [
            "component_not_present",
            "inline_mitigations_already_exist",
            "vulnerable_code_cannot_be_controlled_by_adversary",
            "vulnerable_code_not_in_execute_path",
            "vulnerable_code_not_present",
        ]:
            return True
        elif self.validation == "cyclonedx" and justification._get_type() in [
            "code_not_present",
            "code_not_reachable",
            "requires_configuration",
            "requires_dependency",
            "requires_environment",
            "protected_by_compiler",
            "protected_at_runtime",
            "protected_at_perimeter",
            "protected_by_mitigating_control",
        ]:
            return True
        elif self.validation == "csaf" and justification._get_type() in [
            "component_not_present",
            "inline_mitigations_already_exist",
            "vulnerable_code_cannot_be_controlled_by_adversary",
            "vulnerable_code_not_in_execute_path",
            "vulnerable_code_not_present",
        ]:
            return True
        elif self.validation == "spdx" and justification._get_type() in [
            "componentNotPresent",
            "inlineMitigationsAlreadyExist",
            "vulnerableCodeCannotBeControlledByAdversary",
            "vulnerableCodeNotInExecutePath",
            "vulnerableCodeNotPresent",
        ]:
            return True
        return False

    def add_justification(self, justification):
        if self.validation is None:
            # No validation performed
            self.vulnerability["justifications"].append(justification)
        elif self.validate_justification(justification):
            # Valid field according to specification
            self.vulnerability["justifications"].append(justification)
        elif self.validate_justification(justification):
            # Valid field according to specification
            self.vulnerability["justification"] = justification
        else:
            # Invalid field detected
            self.vulnerability["justifications"].append(None)

    def validate_remediation(self, remediation):
        if self.validation == "openvex":
            # No remediation action to be validated
            return True
        elif self.validation == "cyclonedx" and remediation._get_category() in [
            "can_not_fix",
            "will_not_fix",
            "update",
            "rollback",
            "workaround_available",
        ]:
            return True
        elif self.validation == "csaf" and remediation._get_category() in [
            "mitigation",
            "no_fix_planned",
            "none_available",
            "vendor_fix",
            "workaround",
        ]:
            return True
        elif self.validation == "spdx":
            # No remediation action to be validated
            return True
        return False

    def add_remediation(self, remediation):
        if self.validation is None:
            # No validation performed
            self.vulnerability["remediations"].append(remediation)
        elif self.validate_remediation(remediation):
            # Valid field according to specification
            self.vulnerability["remediations"].append(remediation)
        else:
            # Invalid field detected
            logging.warning("Invalid remediation specified.")

    def set_remediations(self, remediations):
        self.vulnerability["remediations"] = remediations

    def get_remediations(self):
        return self.vulnerability["remediations"]
    
    def get_justifications(self):
        return self.vulnerability["justifications"]

    def get_remediation_product(self, product):
        for remediation in self.vulnerability["remediations"]:
            if remediation._applied_product(product):
                return remediation

    def get_justification_product(self, product):
        for justification in self.vulnerability["justifications"]:
            if justification._applied_product(product):
                return justification
        
        return None

    def set_action(self, value):
        self.vulnerability["action"] = value

    def set_value(self, key, value):
        self.vulnerability[key] = value

    def get_vulnerability(self):
        return self.vulnerability

    def get_value(self, attribute):
        return self.vulnerability.get(attribute, None)

    def debug_vulnerability(self):
        print("OUTPUT:", self.vulnerability)

    def show_vulnerability(self):
        # for key in self.vulnerability:
        #     print(f"{key}    : {self.vulnerability[key]}")
        """Show vuln info."""
        print("")
        print(f"[Vulnerability Details for {self.vulnerability['id']}]")

        if "description" in self.vulnerability:
            print(f"  Description: {self.vulnerability['description']}\n")
        
        if "known_affected" in self.vulnerability:
            print("[known_affected]")
            for product in self.vulnerability['known_affected']:
                print("- " + product)

            print("Remediations:")
            if 'remediations' in self.vulnerability:
                for remediation in self.vulnerability['remediations']:
                    print(f"  Category: {remediation._get_category()}")
                    print(f"  Details: {remediation._get_details()}")
                    #print(f"  Products: {remediation._get_products()}")

        if "known_not_affected" in self.vulnerability:
            print("[known_not_affected]")
            for product in self.vulnerability['known_not_affected']:
                print("- " + product)

    def copy_vulnerability(self, vulnerability_info):
        for key in vulnerability_info:
            self.set_value(key, vulnerability_info[key])

    def get_name(self):
        return self.get_value("name")